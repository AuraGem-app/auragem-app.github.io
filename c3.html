<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Corazón y Texto de Partículas</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', sans-serif;
            touch-action: none;
        }

        canvas { 
            display: block; 
            z-index: 1;
        }

        .btn-back {
            position: fixed; top: 20px; left: 20px; z-index: 9999;
            display: flex; align-items: center; gap: 8px;
            padding: 6px 14px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50px;
            text-decoration: none;
        }

        .mini-logo-btn { width: 26px; height: 26px; border-radius: 50%; object-fit: cover; }
        .btn-back .text { color: white; font-size: 0.7rem; font-weight: 700; text-transform: uppercase; }
    </style>
</head>
<body>
    <a href="index.html" class="btn-back">
        <img src="logo.png" alt="Logo" class="mini-logo-btn">
        <span class="text">AuraGem</span>
    </a>

    <canvas id="heartCanvas"></canvas>

    <script>
        const canvas = document.getElementById('heartCanvas');
        const ctx = canvas.getContext('2d');

        let particles = [];
        let textPoints = [];
        let tick = 0;
        let mouse = { x: -1000, y: -1000, radiusSq: 3000 };
        
        const colors = ['#ff0055', '#ff85a1', '#bc13fe', '#ffffff'];

        // 1. Función para obtener puntos del texto
        function getTextPoints(text) {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            const w = window.innerWidth;
            const h = window.innerHeight;
            tempCanvas.width = w;
            tempCanvas.height = h;

            // Configuración del texto
            const fontSize = Math.min(w / 6, 120);
            tempCtx.font = `900 ${fontSize}px Arial`;
            tempCtx.textAlign = 'center';
            tempCtx.textBaseline = 'middle';
            tempCtx.fillStyle = 'white';
            tempCtx.fillText(text, w / 2, h / 2);

            const imageData = tempCtx.getImageData(0, 0, w, h).data;
            const points = [];
            // Escaneamos el canvas buscando píxeles blancos (el texto)
            const step = window.innerWidth < 600 ? 4 : 6; // Densidad de partículas en texto
            for (let y = 0; y < h; y += step) {
                for (let x = 0; x < w; x += step) {
                    if (imageData[(y * w + x) * 4] > 128) {
                        points.push({ x, y });
                    }
                }
            }
            return points;
        }

        function getHeartPoint(t, scale) {
            let x = scale * 16 * Math.pow(Math.sin(t), 3);
            let y = -scale * (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
            return { x, y };
        }

        function init() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            textPoints = getTextPoints("TE AMO");
            particles = [];

            // Creamos partículas: algunas para el texto, otras para el corazón
            const totalParticles = textPoints.length + 600;

            for (let i = 0; i < totalParticles; i++) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 1.5 + 0.5,
                    color: colors[i % colors.length],
                    angle: Math.random() * Math.PI * 2,
                    speed: (Math.random() * 0.01) + 0.005,
                    // Si el índice es menor a los puntos del texto, su destino es el texto
                    targetType: i < textPoints.length ? 'text' : 'heart',
                    targetIdx: i < textPoints.length ? i : null
                });
            }
        }

        function animate() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            tick += 0.03;
            const pulse = 1 + Math.sin(tick) * 0.1;
            const baseScale = Math.min(canvas.width / 50, canvas.height / 50, 15);
            const currentScale = baseScale * pulse;
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            particles.forEach((p) => {
                let tx, ty;

                if (p.targetType === 'text') {
                    // Destino: Punto específico de la letra
                    tx = textPoints[p.targetIdx].x;
                    ty = textPoints[p.targetIdx].y;
                } else {
                    // Destino: Perímetro del corazón
                    p.angle += p.speed;
                    const hPoint = getHeartPoint(p.angle, currentScale);
                    tx = hPoint.x + centerX;
                    ty = hPoint.y + centerY;
                }

                // Interacción con Mouse/Touch
                const dx = mouse.x - p.x;
                const dy = mouse.y - p.y;
                const distSq = dx * dx + dy * dy;

                if (distSq < mouse.radiusSq) {
                    const dist = Math.sqrt(distSq);
                    const force = (100 - dist) / 100;
                    p.x -= (dx / dist) * force * 10;
                    p.y -= (dy / dist) * force * 10;
                } else {
                    // Suavizado de movimiento hacia el objetivo
                    p.x += (tx - p.x) * 0.07;
                    p.y += (ty - p.y) * 0.07;
                }

                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, p.size, p.size);
            });

            requestAnimationFrame(animate);
        }

        // Eventos
        window.addEventListener('resize', init);
        const updatePos = (e) => {
            const pos = e.touches ? e.touches[0] : e;
            mouse.x = pos.clientX;
            mouse.y = pos.clientY;
        };
        window.addEventListener('mousemove', updatePos);
        window.addEventListener('touchstart', updatePos);
        window.addEventListener('touchmove', updatePos);
        window.addEventListener('touchend', () => { mouse.x = -1000; mouse.y = -1000; });

        init();
        animate();
    </script>
</body>
</html>
